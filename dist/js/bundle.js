/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_crazy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/crazy.js */ \"./src/js/modules/crazy.js\");\n\n\n//# sourceURL=webpack:///./src/js/main.js?");

/***/ }),

/***/ "./src/js/modules/crazy.js":
/*!*********************************!*\
  !*** ./src/js/modules/crazy.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polyfill_object_fit_images_master_dist_ofi_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../polyfill//object-fit-images-master/dist/ofi.min.js */ \"./src/js/polyfill/object-fit-images-master/dist/ofi.min.js\");\n/* harmony import */ var _polyfill_object_fit_images_master_dist_ofi_min_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_polyfill_object_fit_images_master_dist_ofi_min_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _polyfill_IntersectionObserver_master_polyfill_intersection_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../polyfill/IntersectionObserver-master/polyfill/intersection-observer.js */ \"./src/js/polyfill/IntersectionObserver-master/polyfill/intersection-observer.js\");\n/* harmony import */ var _polyfill_IntersectionObserver_master_polyfill_intersection_observer_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_polyfill_IntersectionObserver_master_polyfill_intersection_observer_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n(function (w, d) {\n  // HTMLcollectionやNodeListをforEachで回すための関数\n  var domEach = function domEach(elements, callback) {\n    Array.prototype.forEach.call(elements, function (element, index) {\n      callback(element, index);\n    });\n  };\n\n  var userAgent = navigator.userAgent.toLowerCase();\n  var isIeEdge = userAgent.indexOf('msie') != -1 || userAgent.indexOf('trident') != -1 || userAgent.indexOf('edge') != -1;\n  w.addEventListener('DOMContentLoaded', function () {\n    (function () {\n      //desktopスタイル時のfloat回り込み防止\n      w.addEventListener('load', function () {\n        var pcWidth = window.matchMedia('(orientation: landscape) , (min-width: 768px)');\n        var list = d.getElementsByClassName('js-setSize');\n\n        var removeSize = function removeSize() {\n          for (var i = 0; i < list.length; i++) {\n            list[i].children[0].setAttribute(\"style\", \"\");\n          }\n        };\n\n        var setSize = function setSize() {\n          removeSize();\n\n          for (var i = 0; i < list.length; i++) {\n            console.log(list[i].clientHeight);\n            list[i].children[0].style.height = list[i].clientHeight + 'px';\n          }\n        };\n\n        var checkBP = function checkBP() {\n          if (pcWidth.matches) {\n            //PCの処理\n            w.addEventListener('resize', setSize);\n          } else {\n            //SPの処理\n            removeSize();\n            w.removeEventListener('resize', setSize);\n          }\n        };\n\n        pcWidth.addListener(checkBP);\n        checkBP();\n      });\n    })();\n\n    (function () {\n      var kvCarousel = d.getElementById('js-kv_carousel');\n      var kv_pager = d.getElementById('js-kv_pager');\n      var bannerCarousel = d.getElementById('js-photoGallery_carousel');\n      var kvTime = 5000;\n      var bannerTime = 4000; //フォトカルーセル\n\n      var changeImage = function changeImage(children, pager) {\n        var current = -1;\n        var isAnimate = 'is-animate';\n        domEach(children, function (child) {\n          child.addEventListener('animationend', function () {\n            child.classList.remove(isAnimate);\n          });\n        });\n        return function () {\n          current = current === children.length - 1 ? 0 : current += 1;\n          children[current].classList.add(isAnimate); //pager付きのみpage送り\n\n          if (pager) {\n            for (var i = 0; i < pager.children.length; i++) {\n              pager.children[i].classList[current === i ? 'add' : 'remove']('is-active');\n            }\n          }\n        };\n      };\n\n      var kvAnimate = changeImage(kvCarousel.children, kv_pager);\n      var bannerAnimate = changeImage(bannerCarousel.children); //KVtext\n\n      (function () {\n        var lead = d.getElementById('js-kv_textBox_lead');\n        var isActive = 'is-active';\n        var isShow = 'is-show';\n        w.addEventListener('load', function () {\n          lead.classList.add(isActive);\n          domEach(lead.children, function (child) {\n            child.addEventListener('transitionend', function textTransitionend(e) {\n              e.currentTarget.removeEventListener(e.type, textTransitionend);\n              child.classList.add(isShow); //全てのテキストアニメーションが終了したら、KVスライダーを始動\n\n              if (child == lead.lastElementChild) {\n                kvAnimate();\n                setInterval(function () {\n                  kvAnimate();\n                }, kvTime);\n              }\n            });\n          });\n        });\n      })();\n\n      w.addEventListener('load', function () {\n        var mainSec = d.getElementById('js-contents'); //intersectionObserで各セクション交差を判定\n\n        var intersectionObserverOption = {\n          // ルートとして指定するDOM（無ければviewport）\n          root: null,\n          // 上下100px、左右20px手前で発火\n          rootMargin: '0px 0px -100px',\n          // 交差領域が50%変化するたびに発火\n          threshold: [0, 0.5, 1.0]\n        };\n        var intersectionObserverTarget = d.getElementsByClassName('js-intersection');\n        var intersectionObserver = new IntersectionObserver(callback, intersectionObserverOption);\n\n        for (var i = 0; i < intersectionObserverTarget.length; i++) {\n          intersectionObserver.observe(intersectionObserverTarget[i]);\n        } // 交差したセクションがshown関数実行\n\n\n        var shown = function shown(target) {\n          var children = target.getElementsByClassName('js-shown');\n          var isShown = 'is-shown';\n          var isAnimate = 'is-animate'; //kvからの移動後すぐに交差するセクションのみkvアニメ終了を待機\n\n          if (mainSec.classList.contains(isAnimate)) {\n            mainSec.addEventListener('transitionend', function textTransitionend(e) {\n              e.currentTarget.removeEventListener(e.type, textTransitionend);\n\n              for (var _i = 0; _i < children.length; _i++) {\n                children[_i].classList.add(isShown);\n              }\n            });\n          } else {\n            for (var _i2 = 0; _i2 < children.length; _i2++) {\n              children[_i2].classList.add(isShown);\n            }\n          } //photogalleryセクションに交差した際にフォトスライダーを始動\n\n\n          if (target.classList.contains('p-photoGallery')) {\n            bannerAnimate();\n            setInterval(function () {\n              bannerAnimate();\n            }, bannerTime);\n          }\n        };\n\n        function callback(entries, object) {\n          entries.forEach(function (entry) {\n            // 交差していない\n            if (!entry.isIntersecting) return; // ターゲット要素\n\n            shown(entry.target); // 監視の解除\n\n            object.unobserve(entry.target);\n          });\n        }\n\n        ;\n      });\n    })(); //nav\n\n\n    (function () {\n      var hambuger = d.getElementById('js-nav_hamburger');\n      var popup = d.getElementById('js-nav_popup');\n      var logo = d.getElementById('js-nav_logo');\n      var navsArray = [hambuger, popup, logo];\n      var navLink = d.getElementsByClassName('js-openChild');\n      var navChildren = d.getElementsByClassName('js-nav_popup_children');\n      var popupList = popup.children[0];\n      var popupBg = popup.children[1];\n      var isOpened = 'is-opened';\n      var isOpenedChild = 'is-openedChild';\n      var preIndex = null;\n      var preChild = null;\n\n      var openChild = function openChild(child, index) {\n        child.classList.add(isOpened);\n        navChildren[index].classList.add(isOpened);\n        popupList.classList.add(isOpenedChild);\n        popupBg.classList.add(isOpenedChild);\n        preIndex = index;\n        preChild = child;\n      };\n\n      var closeChild = function closeChild(child, index) {\n        child.classList.remove('is-opened');\n        navChildren[index].classList.remove(isOpened);\n        popupList.classList.remove(isOpenedChild);\n        popupBg.classList.remove(isOpenedChild);\n        preIndex = null;\n        preChild = null;\n      };\n\n      hambuger.addEventListener('click', function () {\n        if (!popup.classList.contains(isOpened)) {\n          for (var i = 0; i < navsArray.length; i++) {\n            navsArray[i].classList.add(isOpened);\n          }\n        } else {\n          for (var _i3 = 0; _i3 < navsArray.length; _i3++) {\n            navsArray[_i3].classList.remove(isOpened);\n          }\n\n          closeChild(preChild, preIndex);\n        }\n      });\n      domEach(navLink, function (child, index) {\n        child.addEventListener('click', function () {\n          if (preIndex === null) {\n            openChild(child, index);\n          } else if (preIndex != index) {\n            navChildren[preIndex].classList.remove(isOpened);\n            navLink[preIndex].classList.remove(isOpened);\n            openChild(child, index);\n          } else {\n            closeChild(child, index);\n          }\n        });\n      });\n    })();\n\n    (function () {\n      var kvSec = d.getElementById('js-kv');\n      var mainSec = d.getElementById('js-contents');\n      var transition = 'transform .8s cubic-bezier(1,0,0,1) .1s'; //transdorm:translste3dの値を返す関数\n\n      var parseTranslate3d = function parseTranslate3d(string) {\n        return string.replace('translate3d', '').match(/-?[\\d\\.]+/g).map(function (value) {\n          return Number(value);\n        });\n      }; //KV→コンテンツ移動\n\n\n      if (!isIeEdge) {\n        //console.log('ie/edge以外');\n        w.addEventListener('load', function () {\n          var kvY, mainSecY;\n          var startY;\n          kvSec.style.transform = 'translate3d(0px,0px,0px)';\n          mainSec.style.transform = 'translate3d(0px,' + w.innerHeight + 'px,0px)'; //デスクトップ・マウス端末の場合にイベントリスナで使用するオブジェクト\n\n          var wheel = {\n            name: 'wheel',\n            up: function up(e) {\n              return w.pageYOffset <= 0 && e.deltaY <= 0 ? true : false;\n            },\n            down: function down(e) {\n              return e.deltaY > 0 ? true : false;\n            }\n          }; //モバイル・タッチ端末の場合にイベントリスナで使用するオブジェクト\n\n          var touch = {\n            name: 'touchmove',\n            up: function up(e) {\n              return w.pageYOffset <= 0 && startY < e.changedTouches[0].pageY ? true : false;\n            },\n            down: function down(e) {\n              return startY > e.changedTouches[0].pageY ? true : false;\n            }\n          }; //モバイルの場合のスワイプ方向を取るためのスタート位置を測定\n\n          var startData = function startData(e) {\n            e.preventDefault();\n            startY = e.touches[0].pageY;\n          }; //whellした際のメイン処理\n\n\n          var scrollJudge = function scrollJudge(e) {\n            var self = this;\n            kvY = parseTranslate3d(kvSec.style.transform)[1];\n            mainSecY = parseTranslate3d(mainSec.style.transform)[1];\n            mainSec.style.transition = transition;\n\n            if (self.event.up(e)) {\n              // console.log('上へのスクロール')\n              if (mainSecY == 0) {\n                e.currentTarget.removeEventListener(self.event.name, self);\n                d.body.style.overflow = 'hidden';\n                mainSec.addEventListener('transitionend', function () {\n                  w.addEventListener(self.event.name, {\n                    handleEvent: self.handleEvent,\n                    event: self.event\n                  });\n                  d.body.style.position = 'fixed';\n                  d.body.style.overflow = 'auto';\n                }, {\n                  once: true\n                });\n                kvSec.style.transform = 'translate3d(0px,0px,0px)';\n                mainSec.style.transform = \"translate3d(0px,\".concat(innerHeight, \"px,0px)\");\n              }\n            } else if (self.event.down(e)) {\n              // console.log('下へのスクロール')\n              if (kvY == 0) {\n                e.currentTarget.removeEventListener(self.event.name, self);\n                mainSec.classList.add('is-animate');\n                mainSec.addEventListener('transitionend', function () {\n                  w.addEventListener(self.event.name, {\n                    handleEvent: self.handleEvent,\n                    event: self.event\n                  });\n                  mainSec.classList.remove('is-animate');\n                  d.body.style.position = 'static';\n                }, {\n                  once: true\n                });\n                kvSec.style.transform = 'translate3d(0px,-100%,0px)';\n                mainSec.style.transform = 'translate3d(0px,0px,0px)';\n              }\n\n              ;\n            }\n          };\n\n          var resize = function resize() {\n            kvY = parseTranslate3d(kvSec.style.transform)[1];\n\n            if (kvY == 0) {\n              mainSec.style.transform = \"translate3d(0px,\".concat(innerHeight, \"px,0px)\");\n            }\n          };\n\n          w.addEventListener('resize', resize);\n          w.addEventListener('touchstart', startData);\n          w.addEventListener('wheel', {\n            handleEvent: scrollJudge,\n            event: wheel\n          });\n          w.addEventListener('touchmove', {\n            handleEvent: scrollJudge,\n            event: touch\n          });\n        });\n      } else {\n        //console.log('ie,edge');\n        w.addEventListener('beforeunload', function () {\n          d.body.scrollTop = d.documentElement.scrollTop = 0;\n          w.location.reload(false);\n        }); //scroll抑制用オブジェクト\n\n        var preventScroll = {\n          x: 0,\n          y: 0,\n          setPos: function setPos() {\n            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : w.pageXOffset;\n            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : w.pageYOffset;\n            this.x = x;\n            this.y = y;\n          },\n          handleEvent: function handleEvent() {\n            w.scrollTo(this.x, this.y);\n          },\n          enable: function enable() {\n            this.setPos();\n            w.addEventListener('scroll', this);\n          },\n          disable: function disable() {\n            w.removeEventListener('scroll', this);\n          }\n        };\n        preventScroll.enable();\n        w.addEventListener('load', function () {\n          var footer = d.getElementById('js-footer');\n          var kvY;\n          preventScroll.disable();\n          kvSec.style.transform = 'translate3d(0px,0px,0px)';\n          mainSec.style.transform = \"translate3d(0px,\".concat(innerHeight, \"px,0px)\");\n\n          var scrollJudge = function scrollJudge() {\n            kvSec.style.transition = transition;\n            mainSec.style.transition = transition;\n            kvY = parseTranslate3d(kvSec.style.transform)[1];\n\n            if (kvSec.offsetHeight + 10 <= w.pageYOffset + w.innerHeight) {\n              if (kvY == '0') {\n                // console.log('下へのスクロール')\n                mainSec.classList.add('is-animate');\n                w.removeEventListener('scroll', scrollJudge);\n                preventScroll.enable();\n                mainSec.addEventListener('transitionend', function transitionendDown(e) {\n                  e.currentTarget.removeEventListener(e.type, transitionendDown);\n                  preventScroll.disable();\n                  w.addEventListener('scroll', scrollJudge);\n                  mainSec.classList.remove('is-animate');\n                });\n                kvSec.style.transform = 'translate3d(0px,-100%,0px)';\n                mainSec.style.transform = \"translate3d(0px,\".concat(w.pageYOffset, \"px,0px)\");\n                footer.style.transform = \"translate3d(0px,\".concat(w.pageYOffset, \"px,0px)\");\n              }\n            } else if (w.pageYOffset == 0) {\n              if (kvY == '-100') {\n                // console.log('上へのスクロール')\n                w.removeEventListener('scroll', scrollJudge);\n                preventScroll.enable();\n                kvSec.addEventListener('transitionend', function transitionendUp(e) {\n                  e.currentTarget.removeEventListener(e.type, transitionendUp);\n                  w.addEventListener('scroll', scrollJudge);\n                  preventScroll.disable();\n                });\n                kvSec.style.transform = 'translate3d(0px,0px,0px)';\n                mainSec.style.transform = \"translate3d(0px,\".concat(w.innerHeight, \"px,0px)\");\n              }\n            }\n          };\n\n          var resize = function resize() {\n            kvY = parseTranslate3d(kvSec.style.transform)[1];\n\n            if (kvY == 0) {\n              mainSec.style.transform = \"translate3d(0px,\".concat(innerHeight, \"px,0px)\");\n            }\n          };\n\n          w.addEventListener('resize', resize);\n          w.addEventListener('scroll', scrollJudge);\n        });\n      }\n    })();\n  });\n})(window, document);\n\n//# sourceURL=webpack:///./src/js/modules/crazy.js?");

/***/ }),

/***/ "./src/js/polyfill/IntersectionObserver-master/polyfill/intersection-observer.js":
/*!***************************************************************************************!*\
  !*** ./src/js/polyfill/IntersectionObserver-master/polyfill/intersection-observer.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n(function () {\n  'use strict'; // Exit early if we're not running in a browser.\n\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) !== 'object') {\n    return;\n  } // Exit early if all IntersectionObserver and IntersectionObserverEntry\n  // features are natively supported.\n\n\n  if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n    // Minimal polyfill for Edge 15's lack of `isIntersecting`\n    // See: https://github.com/w3c/IntersectionObserver/issues/211\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n      Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {\n        get: function get() {\n          return this.intersectionRatio > 0;\n        }\n      });\n    }\n\n    return;\n  }\n  /**\n   * A local reference to the document.\n   */\n\n\n  var document = window.document;\n  /**\n   * An IntersectionObserver registry. This registry exists to hold a strong\n   * reference to IntersectionObserver instances currently observing a target\n   * element. Without this registry, instances without another reference may be\n   * garbage collected.\n   */\n\n  var registry = [];\n  /**\n   * Creates the global IntersectionObserverEntry constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n   * @param {Object} entry A dictionary of instance properties.\n   * @constructor\n   */\n\n  function IntersectionObserverEntry(entry) {\n    this.time = entry.time;\n    this.target = entry.target;\n    this.rootBounds = entry.rootBounds;\n    this.boundingClientRect = entry.boundingClientRect;\n    this.intersectionRect = entry.intersectionRect || getEmptyRect();\n    this.isIntersecting = !!entry.intersectionRect; // Calculates the intersection ratio.\n\n    var targetRect = this.boundingClientRect;\n    var targetArea = targetRect.width * targetRect.height;\n    var intersectionRect = this.intersectionRect;\n    var intersectionArea = intersectionRect.width * intersectionRect.height; // Sets intersection ratio.\n\n    if (targetArea) {\n      // Round the intersection ratio to avoid floating point math issues:\n      // https://github.com/w3c/IntersectionObserver/issues/324\n      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n    } else {\n      // If area is zero and is intersecting, sets to 1, otherwise to 0\n      this.intersectionRatio = this.isIntersecting ? 1 : 0;\n    }\n  }\n  /**\n   * Creates the global IntersectionObserver constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n   * @param {Function} callback The function to be invoked after intersection\n   *     changes have queued. The function is not invoked if the queue has\n   *     been emptied by calling the `takeRecords` method.\n   * @param {Object=} opt_options Optional configuration options.\n   * @constructor\n   */\n\n\n  function IntersectionObserver(callback, opt_options) {\n    var options = opt_options || {};\n\n    if (typeof callback != 'function') {\n      throw new Error('callback must be a function');\n    }\n\n    if (options.root && options.root.nodeType != 1) {\n      throw new Error('root must be an Element');\n    } // Binds and throttles `this._checkForIntersections`.\n\n\n    this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT); // Private properties.\n\n    this._callback = callback;\n    this._observationTargets = [];\n    this._queuedEntries = [];\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin); // Public properties.\n\n    this.thresholds = this._initThresholds(options.threshold);\n    this.root = options.root || null;\n    this.rootMargin = this._rootMarginValues.map(function (margin) {\n      return margin.value + margin.unit;\n    }).join(' ');\n  }\n  /**\n   * The minimum interval within which the document will be checked for\n   * intersection changes.\n   */\n\n\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n  /**\n   * The frequency in which the polyfill polls for intersection changes.\n   * this can be updated on a per instance basis and must be set prior to\n   * calling `observe` on the first target.\n   */\n\n  IntersectionObserver.prototype.POLL_INTERVAL = null;\n  /**\n   * Use a mutation observer on the root element\n   * to detect intersection changes.\n   */\n\n  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n  /**\n   * Starts observing a target element for intersection changes based on\n   * the thresholds values.\n   * @param {Element} target The DOM element to observe.\n   */\n\n  IntersectionObserver.prototype.observe = function (target) {\n    var isTargetAlreadyObserved = this._observationTargets.some(function (item) {\n      return item.element == target;\n    });\n\n    if (isTargetAlreadyObserved) {\n      return;\n    }\n\n    if (!(target && target.nodeType == 1)) {\n      throw new Error('target must be an Element');\n    }\n\n    this._registerInstance();\n\n    this._observationTargets.push({\n      element: target,\n      entry: null\n    });\n\n    this._monitorIntersections();\n\n    this._checkForIntersections();\n  };\n  /**\n   * Stops observing a target element for intersection changes.\n   * @param {Element} target The DOM element to observe.\n   */\n\n\n  IntersectionObserver.prototype.unobserve = function (target) {\n    this._observationTargets = this._observationTargets.filter(function (item) {\n      return item.element != target;\n    });\n\n    if (!this._observationTargets.length) {\n      this._unmonitorIntersections();\n\n      this._unregisterInstance();\n    }\n  };\n  /**\n   * Stops observing all target elements for intersection changes.\n   */\n\n\n  IntersectionObserver.prototype.disconnect = function () {\n    this._observationTargets = [];\n\n    this._unmonitorIntersections();\n\n    this._unregisterInstance();\n  };\n  /**\n   * Returns any queue entries that have not yet been reported to the\n   * callback and clears the queue. This can be used in conjunction with the\n   * callback to obtain the absolute most up-to-date intersection information.\n   * @return {Array} The currently queued entries.\n   */\n\n\n  IntersectionObserver.prototype.takeRecords = function () {\n    var records = this._queuedEntries.slice();\n\n    this._queuedEntries = [];\n    return records;\n  };\n  /**\n   * Accepts the threshold value from the user configuration object and\n   * returns a sorted array of unique threshold values. If a value is not\n   * between 0 and 1 and error is thrown.\n   * @private\n   * @param {Array|number=} opt_threshold An optional threshold value or\n   *     a list of threshold values, defaulting to [0].\n   * @return {Array} A sorted list of unique and valid threshold values.\n   */\n\n\n  IntersectionObserver.prototype._initThresholds = function (opt_threshold) {\n    var threshold = opt_threshold || [0];\n    if (!Array.isArray(threshold)) threshold = [threshold];\n    return threshold.sort().filter(function (t, i, a) {\n      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n        throw new Error('threshold must be a number between 0 and 1 inclusively');\n      }\n\n      return t !== a[i - 1];\n    });\n  };\n  /**\n   * Accepts the rootMargin value from the user configuration object\n   * and returns an array of the four margin values as an object containing\n   * the value and unit properties. If any of the values are not properly\n   * formatted or use a unit other than px or %, and error is thrown.\n   * @private\n   * @param {string=} opt_rootMargin An optional rootMargin value,\n   *     defaulting to '0px'.\n   * @return {Array<Object>} An array of margin objects with the keys\n   *     value and unit.\n   */\n\n\n  IntersectionObserver.prototype._parseRootMargin = function (opt_rootMargin) {\n    var marginString = opt_rootMargin || '0px';\n    var margins = marginString.split(/\\s+/).map(function (margin) {\n      var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n\n      if (!parts) {\n        throw new Error('rootMargin must be specified in pixels or percent');\n      }\n\n      return {\n        value: parseFloat(parts[1]),\n        unit: parts[2]\n      };\n    }); // Handles shorthand.\n\n    margins[1] = margins[1] || margins[0];\n    margins[2] = margins[2] || margins[0];\n    margins[3] = margins[3] || margins[1];\n    return margins;\n  };\n  /**\n   * Starts polling for intersection changes if the polling is not already\n   * happening, and if the page's visibility state is visible.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._monitorIntersections = function () {\n    if (!this._monitoringIntersections) {\n      this._monitoringIntersections = true; // If a poll interval is set, use polling instead of listening to\n      // resize and scroll events or DOM mutations.\n\n      if (this.POLL_INTERVAL) {\n        this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL);\n      } else {\n        addEvent(window, 'resize', this._checkForIntersections, true);\n        addEvent(document, 'scroll', this._checkForIntersections, true);\n\n        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n          this._domObserver = new MutationObserver(this._checkForIntersections);\n\n          this._domObserver.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n          });\n        }\n      }\n    }\n  };\n  /**\n   * Stops polling for intersection changes.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._unmonitorIntersections = function () {\n    if (this._monitoringIntersections) {\n      this._monitoringIntersections = false;\n      clearInterval(this._monitoringInterval);\n      this._monitoringInterval = null;\n      removeEvent(window, 'resize', this._checkForIntersections, true);\n      removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if (this._domObserver) {\n        this._domObserver.disconnect();\n\n        this._domObserver = null;\n      }\n    }\n  };\n  /**\n   * Scans each observation target for intersection changes and adds them\n   * to the internal entries queue. If new entries are found, it\n   * schedules the callback to be invoked.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._checkForIntersections = function () {\n    var rootIsInDom = this._rootIsInDom();\n\n    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n    this._observationTargets.forEach(function (item) {\n      var target = item.element;\n      var targetRect = getBoundingClientRect(target);\n\n      var rootContainsTarget = this._rootContainsTarget(target);\n\n      var oldEntry = item.entry;\n\n      var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, rootRect);\n\n      var newEntry = item.entry = new IntersectionObserverEntry({\n        time: now(),\n        target: target,\n        boundingClientRect: targetRect,\n        rootBounds: rootRect,\n        intersectionRect: intersectionRect\n      });\n\n      if (!oldEntry) {\n        this._queuedEntries.push(newEntry);\n      } else if (rootIsInDom && rootContainsTarget) {\n        // If the new entry intersection ratio has crossed any of the\n        // thresholds, add a new entry.\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n          this._queuedEntries.push(newEntry);\n        }\n      } else {\n        // If the root is not in the DOM or target is not contained within\n        // root but the previous entry for this target had an intersection,\n        // add a new record indicating removal.\n        if (oldEntry && oldEntry.isIntersecting) {\n          this._queuedEntries.push(newEntry);\n        }\n      }\n    }, this);\n\n    if (this._queuedEntries.length) {\n      this._callback(this.takeRecords(), this);\n    }\n  };\n  /**\n   * Accepts a target and root rect computes the intersection between then\n   * following the algorithm in the spec.\n   * TODO(philipwalton): at this time clip-path is not considered.\n   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n   * @param {Element} target The target DOM element\n   * @param {Object} rootRect The bounding rect of the root after being\n   *     expanded by the rootMargin value.\n   * @return {?Object} The final intersection rect object or undefined if no\n   *     intersection is found.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, rootRect) {\n    // If the element isn't displayed, an intersection can't happen.\n    if (window.getComputedStyle(target).display == 'none') return;\n    var targetRect = getBoundingClientRect(target);\n    var intersectionRect = targetRect;\n    var parent = getParentNode(target);\n    var atRoot = false;\n\n    while (!atRoot) {\n      var parentRect = null;\n      var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {}; // If the parent isn't displayed, an intersection can't happen.\n\n      if (parentComputedStyle.display == 'none') return;\n\n      if (parent == this.root || parent == document) {\n        atRoot = true;\n        parentRect = rootRect;\n      } else {\n        // If the element has a non-visible overflow, and it's not the <body>\n        // or <html> element, update the intersection rect.\n        // Note: <body> and <html> cannot be clipped to a rect that's not also\n        // the document rect, so no need to compute a new intersection.\n        if (parent != document.body && parent != document.documentElement && parentComputedStyle.overflow != 'visible') {\n          parentRect = getBoundingClientRect(parent);\n        }\n      } // If either of the above conditionals set a new parentRect,\n      // calculate new intersection data.\n\n\n      if (parentRect) {\n        intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n        if (!intersectionRect) break;\n      }\n\n      parent = getParentNode(parent);\n    }\n\n    return intersectionRect;\n  };\n  /**\n   * Returns the root rect after being expanded by the rootMargin value.\n   * @return {Object} The expanded root rect.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._getRootRect = function () {\n    var rootRect;\n\n    if (this.root) {\n      rootRect = getBoundingClientRect(this.root);\n    } else {\n      // Use <html>/<body> instead of window since scroll bars affect size.\n      var html = document.documentElement;\n      var body = document.body;\n      rootRect = {\n        top: 0,\n        left: 0,\n        right: html.clientWidth || body.clientWidth,\n        width: html.clientWidth || body.clientWidth,\n        bottom: html.clientHeight || body.clientHeight,\n        height: html.clientHeight || body.clientHeight\n      };\n    }\n\n    return this._expandRectByRootMargin(rootRect);\n  };\n  /**\n   * Accepts a rect and expands it by the rootMargin value.\n   * @param {Object} rect The rect object to expand.\n   * @return {Object} The expanded rect.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {\n    var margins = this._rootMarginValues.map(function (margin, i) {\n      return margin.unit == 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;\n    });\n\n    var newRect = {\n      top: rect.top - margins[0],\n      right: rect.right + margins[1],\n      bottom: rect.bottom + margins[2],\n      left: rect.left - margins[3]\n    };\n    newRect.width = newRect.right - newRect.left;\n    newRect.height = newRect.bottom - newRect.top;\n    return newRect;\n  };\n  /**\n   * Accepts an old and new entry and returns true if at least one of the\n   * threshold values has been crossed.\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n   *    particular target element or null if no previous entry exists.\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\n   *    particular target element.\n   * @return {boolean} Returns true if a any threshold has been crossed.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._hasCrossedThreshold = function (oldEntry, newEntry) {\n    // To make comparing easier, an entry that has a ratio of 0\n    // but does not actually intersect is given a value of -1\n    var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;\n    var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1; // Ignore unchanged ratios\n\n    if (oldRatio === newRatio) return;\n\n    for (var i = 0; i < this.thresholds.length; i++) {\n      var threshold = this.thresholds[i]; // Return true if an entry matches a threshold or if the new ratio\n      // and the old ratio are on the opposite sides of a threshold.\n\n      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {\n        return true;\n      }\n    }\n  };\n  /**\n   * Returns whether or not the root element is an element and is in the DOM.\n   * @return {boolean} True if the root element is an element and is in the DOM.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._rootIsInDom = function () {\n    return !this.root || containsDeep(document, this.root);\n  };\n  /**\n   * Returns whether or not the target element is a child of root.\n   * @param {Element} target The target element to check.\n   * @return {boolean} True if the target element is a child of root.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._rootContainsTarget = function (target) {\n    return containsDeep(this.root || document, target);\n  };\n  /**\n   * Adds the instance to the global IntersectionObserver registry if it isn't\n   * already present.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._registerInstance = function () {\n    if (registry.indexOf(this) < 0) {\n      registry.push(this);\n    }\n  };\n  /**\n   * Removes the instance from the global IntersectionObserver registry.\n   * @private\n   */\n\n\n  IntersectionObserver.prototype._unregisterInstance = function () {\n    var index = registry.indexOf(this);\n    if (index != -1) registry.splice(index, 1);\n  };\n  /**\n   * Returns the result of the performance.now() method or null in browsers\n   * that don't support the API.\n   * @return {number} The elapsed time since the page was requested.\n   */\n\n\n  function now() {\n    return window.performance && performance.now && performance.now();\n  }\n  /**\n   * Throttles a function and delays its execution, so it's only called at most\n   * once within a given time period.\n   * @param {Function} fn The function to throttle.\n   * @param {number} timeout The amount of time that must pass before the\n   *     function can be called again.\n   * @return {Function} The throttled function.\n   */\n\n\n  function throttle(fn, timeout) {\n    var timer = null;\n    return function () {\n      if (!timer) {\n        timer = setTimeout(function () {\n          fn();\n          timer = null;\n        }, timeout);\n      }\n    };\n  }\n  /**\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n   * @param {Node} node The DOM node to add the event handler to.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to add.\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\n   *     phase. Note: this only works in modern browsers.\n   */\n\n\n  function addEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.addEventListener == 'function') {\n      node.addEventListener(event, fn, opt_useCapture || false);\n    } else if (typeof node.attachEvent == 'function') {\n      node.attachEvent('on' + event, fn);\n    }\n  }\n  /**\n   * Removes a previously added event handler from a DOM node.\n   * @param {Node} node The DOM node to remove the event handler from.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to remove.\n   * @param {boolean} opt_useCapture If the event handler was added with this\n   *     flag set to true, it should be set to true here in order to remove it.\n   */\n\n\n  function removeEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.removeEventListener == 'function') {\n      node.removeEventListener(event, fn, opt_useCapture || false);\n    } else if (typeof node.detatchEvent == 'function') {\n      node.detatchEvent('on' + event, fn);\n    }\n  }\n  /**\n   * Returns the intersection between two rect objects.\n   * @param {Object} rect1 The first rect.\n   * @param {Object} rect2 The second rect.\n   * @return {?Object} The intersection rect or undefined if no intersection\n   *     is found.\n   */\n\n\n  function computeRectIntersection(rect1, rect2) {\n    var top = Math.max(rect1.top, rect2.top);\n    var bottom = Math.min(rect1.bottom, rect2.bottom);\n    var left = Math.max(rect1.left, rect2.left);\n    var right = Math.min(rect1.right, rect2.right);\n    var width = right - left;\n    var height = bottom - top;\n    return width >= 0 && height >= 0 && {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      width: width,\n      height: height\n    };\n  }\n  /**\n   * Shims the native getBoundingClientRect for compatibility with older IE.\n   * @param {Element} el The element whose bounding rect to get.\n   * @return {Object} The (possibly shimmed) rect of the element.\n   */\n\n\n  function getBoundingClientRect(el) {\n    var rect;\n\n    try {\n      rect = el.getBoundingClientRect();\n    } catch (err) {// Ignore Windows 7 IE11 \"Unspecified error\"\n      // https://github.com/w3c/IntersectionObserver/pull/205\n    }\n\n    if (!rect) return getEmptyRect(); // Older IE\n\n    if (!(rect.width && rect.height)) {\n      rect = {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    }\n\n    return rect;\n  }\n  /**\n   * Returns an empty rect object. An empty rect is returned when an element\n   * is not in the DOM.\n   * @return {Object} The empty rect.\n   */\n\n\n  function getEmptyRect() {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  /**\n   * Checks to see if a parent element contains a child element (including inside\n   * shadow DOM).\n   * @param {Node} parent The parent element.\n   * @param {Node} child The child element.\n   * @return {boolean} True if the parent node contains the child node.\n   */\n\n\n  function containsDeep(parent, child) {\n    var node = child;\n\n    while (node) {\n      if (node == parent) return true;\n      node = getParentNode(node);\n    }\n\n    return false;\n  }\n  /**\n   * Gets the parent node of an element or its host element if the parent node\n   * is a shadow root.\n   * @param {Node} node The node whose parent to get.\n   * @return {Node|null} The parent node or null if no parent exists.\n   */\n\n\n  function getParentNode(node) {\n    var parent = node.parentNode;\n\n    if (parent && parent.nodeType == 11 && parent.host) {\n      // If the parent is a shadow root, return the host element.\n      return parent.host;\n    }\n\n    if (parent && parent.assignedSlot) {\n      // If the parent is distributed in a <slot>, return the parent of a slot.\n      return parent.assignedSlot.parentNode;\n    }\n\n    return parent;\n  } // Exposes the constructors globally.\n\n\n  window.IntersectionObserver = IntersectionObserver;\n  window.IntersectionObserverEntry = IntersectionObserverEntry;\n})();\n\n//# sourceURL=webpack:///./src/js/polyfill/IntersectionObserver-master/polyfill/intersection-observer.js?");

/***/ }),

/***/ "./src/js/polyfill/object-fit-images-master/dist/ofi.min.js":
/*!******************************************************************!*\
  !*** ./src/js/polyfill/object-fit-images-master/dist/ofi.min.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! npm.im/object-fit-images 3.2.4 */\nvar objectFitImages = function () {\n  \"use strict\";\n\n  function t(t, e) {\n    return \"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='\" + t + \"' height='\" + e + \"'%3E%3C/svg%3E\";\n  }\n\n  function e(t) {\n    if (t.srcset && !p && window.picturefill) {\n      var e = window.picturefill._;\n      t[e.ns] && t[e.ns].evaled || e.fillImg(t, {\n        reselect: !0\n      }), t[e.ns].curSrc || (t[e.ns].supported = !1, e.fillImg(t, {\n        reselect: !0\n      })), t.currentSrc = t[e.ns].curSrc || t.src;\n    }\n  }\n\n  function i(t) {\n    for (var e, i = getComputedStyle(t).fontFamily, r = {}; null !== (e = u.exec(i));) {\n      r[e[1]] = e[2];\n    }\n\n    return r;\n  }\n\n  function r(e, i, r) {\n    var n = t(i || 1, r || 0);\n    b.call(e, \"src\") !== n && h.call(e, \"src\", n);\n  }\n\n  function n(t, e) {\n    t.naturalWidth ? e(t) : setTimeout(n, 100, t, e);\n  }\n\n  function c(t) {\n    var c = i(t),\n        o = t[l];\n\n    if (c[\"object-fit\"] = c[\"object-fit\"] || \"fill\", !o.img) {\n      if (\"fill\" === c[\"object-fit\"]) return;\n      if (!o.skipTest && f && !c[\"object-position\"]) return;\n    }\n\n    if (!o.img) {\n      o.img = new Image(t.width, t.height), o.img.srcset = b.call(t, \"data-ofi-srcset\") || t.srcset, o.img.src = b.call(t, \"data-ofi-src\") || t.src, h.call(t, \"data-ofi-src\", t.src), t.srcset && h.call(t, \"data-ofi-srcset\", t.srcset), r(t, t.naturalWidth || t.width, t.naturalHeight || t.height), t.srcset && (t.srcset = \"\");\n\n      try {\n        s(t);\n      } catch (t) {\n        window.console && console.warn(\"https://bit.ly/ofi-old-browser\");\n      }\n    }\n\n    e(o.img), t.style.backgroundImage = 'url(\"' + (o.img.currentSrc || o.img.src).replace(/\"/g, '\\\\\"') + '\")', t.style.backgroundPosition = c[\"object-position\"] || \"center\", t.style.backgroundRepeat = \"no-repeat\", t.style.backgroundOrigin = \"content-box\", /scale-down/.test(c[\"object-fit\"]) ? n(o.img, function () {\n      o.img.naturalWidth > t.width || o.img.naturalHeight > t.height ? t.style.backgroundSize = \"contain\" : t.style.backgroundSize = \"auto\";\n    }) : t.style.backgroundSize = c[\"object-fit\"].replace(\"none\", \"auto\").replace(\"fill\", \"100% 100%\"), n(o.img, function (e) {\n      r(t, e.naturalWidth, e.naturalHeight);\n    });\n  }\n\n  function s(t) {\n    var e = {\n      get: function get(e) {\n        return t[l].img[e ? e : \"src\"];\n      },\n      set: function set(e, i) {\n        return t[l].img[i ? i : \"src\"] = e, h.call(t, \"data-ofi-\" + i, e), c(t), e;\n      }\n    };\n    Object.defineProperty(t, \"src\", e), Object.defineProperty(t, \"currentSrc\", {\n      get: function get() {\n        return e.get(\"currentSrc\");\n      }\n    }), Object.defineProperty(t, \"srcset\", {\n      get: function get() {\n        return e.get(\"srcset\");\n      },\n      set: function set(t) {\n        return e.set(t, \"srcset\");\n      }\n    });\n  }\n\n  function o() {\n    function t(t, e) {\n      return t[l] && t[l].img && (\"src\" === e || \"srcset\" === e) ? t[l].img : t;\n    }\n\n    d || (HTMLImageElement.prototype.getAttribute = function (e) {\n      return b.call(t(this, e), e);\n    }, HTMLImageElement.prototype.setAttribute = function (e, i) {\n      return h.call(t(this, e), e, String(i));\n    });\n  }\n\n  function a(t, e) {\n    var i = !y && !t;\n    if (e = e || {}, t = t || \"img\", d && !e.skipTest || !m) return !1;\n    \"img\" === t ? t = document.getElementsByTagName(\"img\") : \"string\" == typeof t ? t = document.querySelectorAll(t) : \"length\" in t || (t = [t]);\n\n    for (var r = 0; r < t.length; r++) {\n      t[r][l] = t[r][l] || {\n        skipTest: e.skipTest\n      }, c(t[r]);\n    }\n\n    i && (document.body.addEventListener(\"load\", function (t) {\n      \"IMG\" === t.target.tagName && a(t.target, {\n        skipTest: e.skipTest\n      });\n    }, !0), y = !0, t = \"img\"), e.watchMQ && window.addEventListener(\"resize\", a.bind(null, t, {\n      skipTest: e.skipTest\n    }));\n  }\n\n  var l = \"fregante:object-fit-images\",\n      u = /(object-fit|object-position)\\s*:\\s*([-.\\w\\s%]+)/g,\n      g = \"undefined\" == typeof Image ? {\n    style: {\n      \"object-position\": 1\n    }\n  } : new Image(),\n      f = \"object-fit\" in g.style,\n      d = \"object-position\" in g.style,\n      m = \"background-size\" in g.style,\n      p = \"string\" == typeof g.currentSrc,\n      b = g.getAttribute,\n      h = g.setAttribute,\n      y = !1;\n  return a.supportsObjectFit = f, a.supportsObjectPosition = d, o(), a;\n}();\n\nobjectFitImages();\n\n//# sourceURL=webpack:///./src/js/polyfill/object-fit-images-master/dist/ofi.min.js?");

/***/ })

/******/ });